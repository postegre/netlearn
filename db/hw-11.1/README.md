Домашнее задание к занятию «Базы данных, их типы»


Задание 1. СУБД


Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Приведите ответ в свободной форме.


Решение


1.1. Бюджетирование и аналитика
Подходящая СУБД: реляционная СУБД, например, PostgreSQL или Oracle.
Почему:

Высокая поддержка ACID-транзакций, что критично для финансов.

Хорошая поддержка аналитических запросов и хранимых процедур.

Надёжная интеграция с BI-инструментами (Power BI, Tableau).

Масштабируемость и возможность строить data warehouse (например, с использованием PostgreSQL + Citus).

1.1.* Хеширование
Если речь о хешировании в рамках API или ETL-процессов, для ускорения можно использовать:

C-библиотеки через FFI (например, OpenSSL, libcrypto).

Быстрые Python/Go/NodeJS API, такие как Blake3, xxHash, вместо SHA256/SHA512.

Использовать параллельную обработку и асинхронные очереди (Kafka, Celery).


1.2. Лендинги и CRM
СУБД для лендингов: NoSQL, например, MongoDB или Firebase Realtime Database / Firestore.
СУБД для CRM: реляционная, например, MySQL или PostgreSQL.
Почему:

Лендинги часто работают с полу-структурированными данными, нужны гибкие схемы и быстрая запись.

CRM — это сложные связи, фильтры, отчеты, транзакции → нужна структурированная реляционная СУБД.

1.2.* Можно ли закрыть одной СУБД?
Да, например, с использованием PostgreSQL с JSONB:

Структурированные данные CRM — в обычных таблицах.

Данные с лендингов — в JSONB-полях.

Возможность индексации JSONB позволяет эффективно работать даже с полу-структурированными данными.


1.3. База знаний для контроля качества
Подходящая СУБД: реляционная или документоориентированная, например, MongoDB или SQLite (если простая внутренняя база).
Почему:

Чёткая структура, иерархия документов, удобный поиск.

Возможность легко обновлять и расширять базу без сложных миграций.

1.3.* Можно ли использовать уже существующую СУБД?
Да, если CRM строится на PostgreSQL, можно:

Добавить отдельную схему или таблицы с учебными материалами.

Использовать полнотекстовый поиск PostgreSQL.

Сделать отдельный интерфейс с правами доступа к этой части БД.

1.4. Логистика и маршруты
Подходящая СУБД: графовая, например, Neo4j или ArangoDB.
Почему:

Быстрый поиск кратчайших маршрутов и связей.

Отлично подходит для задач маршрутизации и логистических схем.

1.4.* Интеграция с отделом закупок
Вариант 1: подключить отдел закупок как клиента графовой БД, связав товары, маршруты и склады.

Вариант 2: сделать отдельную реляционную БД для закупок (если данные не сильно связаны), но с интеграцией через ETL или API.

1.5. Одна СУБД на всё?*
Теоретически — да, на практике — не рекомендуется. Если есть необходимость централизовать, можно выбрать:
PostgreSQL с расширениями:

PostGIS — для геоданных и логистики,

JSONB — для гибкой структуры (лендинги, база знаний),

FDW (Foreign Data Wrappers) — для подключения внешних источников (например, CRM или MongoDB).
Или использовать ClickHouse для аналитики + PostgreSQL для операций.


Задание 2. Транзакции
2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

Приведите ответ в свободной форме.


Решение



2.1. Пополнение баланса вручную — 6 шагов
Инициация транзакции пользователем
Пользователь вводит номер телефона и сумму, выбирает способ оплаты (карта, кошелёк и т.д.), нажимает "Пополнить".

Проверка данных и валидация

 - Проверяется корректность номера телефона.

 - Проверяется доступность провайдера связи.

 - Проверяется сумма (не ниже/выше допустимых лимитов).

Резервирование средств на источнике платежа

 - У плательщика временно блокируются средства на карте/кошельке.

 - Если недостаточно средств или платёж отклонён — операция прерывается.

Создание транзакции в системе и начало записи в СУБД

 - Создаётся запись транзакции с текущим статусом: "В процессе".

 - Записывается лог с деталями: время, сумма, номер, платёжный метод.

Передача данных оператору связи / платёжному шлюзу

 - Осуществляется запрос на пополнение от оператора мобильной связи.

 - Получается ответ: успешное зачисление или ошибка (например, номер не существует).

Завершение транзакции

 - Если всё прошло успешно — статус транзакции обновляется на "Успешно", средства списываются окончательно, пользователю показывается подтверждение.

 - В случае ошибки — транзакция откатывается, средства возвращаются, логируется сбой, пользователю показывается сообщение об ошибке.


2.1.* Пополнение через автоплатёж*
Автоплатёж — это отложенный или повторяющийся платёж, запускаемый по событию или расписанию.

Настройка автоплатежа
 - Пользователь задаёт условия: сумма, номер, способ оплаты, порог срабатывания (например, "если баланс ниже 50₽").

Регулярная проверка условий

 - Работает фоновый процесс/скрипт/триггер, который проверяет баланс.

 - Если условие выполнено — генерируется событие на пополнение.

Инициация транзакции системой (а не пользователем)

 - Система создает платёж по заданным параметрам.

 - Генерируется уникальный ID операции, чтобы избежать дублирования.

Проверка и резервирование средств

 - Валидация, проверка карты, резервирование.

 - Возможно — дополнительные проверки: срок действия карты, повторные ошибки.

Пополнение баланса и обновление транзакции

 - Отправка запроса оператору.

 - Ответ → изменение статуса транзакции.

 - Отправка уведомления пользователю (push/SMS/email).

Логирование, отчёт и перезапуск цикла

 - Лог операции сохраняется.

 - Если была ошибка — попытка в следующий цикл, возможно уведомление.

 - Если успешно — следующее срабатывание в будущем (если автоплатёж регулярный).


Задание 3. SQL vs NoSQL
3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.

3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

Приведите ответ в свободной форме.


Решение

3.1. Преимущества SQL-систем (реляционных СУБД) перед NoSQL

Строгая структура и целостность данных (ACID)
 - SQL-СУБД гарантируют согласованность и надёжность данных благодаря поддержке транзакций (ACID). Это особенно важно для финансов, логистики и других критичных систем.

Сложные запросы и связи (JOIN, GROUP BY, подзапросы)
 - Реляционные СУБД идеально подходят для работы с взаимосвязанными таблицами и позволяют выполнять мощные аналитические запросы.

Стандартизированный язык SQL
 - Универсальный и широко поддерживаемый язык запросов. Это упрощает миграции между СУБД и облегчает обучение персонала.

Развитая экосистема и инструменты
 - BI-системы, ORM-фреймворки, визуальные редакторы, системы мониторинга — всё давно и хорошо интегрировано под SQL-БД.

Поддержка строгих ограничений и триггеров
 - Возможность задать ограничения на уровне схемы (уникальность, внешние ключи, проверка и т.п.) помогает избежать логических ошибок в данных.


3.1.* Преимущества NewSQL по сравнению с SQL и NoSQL
Это системы вроде CockroachDB, Google Spanner, TiDB, YugabyteDB, которые предлагают:

Преимущества NewSQL:

Масштабируемость как у NoSQL
 - Горизонтальное масштабирование без потери согласованности. Можно распределять данные по кластерам без боли, как в NoSQL.

Полноценная поддержка SQL и ACID
 - В отличие от NoSQL, сохраняется возможность использовать SQL-запросы и строгие транзакции — как в традиционных реляционных СУБД.

Автоматическое восстановление и отказоустойчивость
М - ногие NewSQL СУБД изначально проектировались для распределённых сред, поэтому обеспечивают отказоустойчивость на уровне инфраструктуры.

Гибкость как у NoSQL, но с управляемой схемой
 - Некоторые позволяют использовать полу-структурированные данные или миграции схем без жёсткой привязки — как в MongoDB, но с контролем.

Подходит для real-time big data систем
 - Благодаря распределённости и транзакциям можно строить системы с высокой нагрузкой, которые требуют как точности, так и скорости.


Задание 4. Кластеры
Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

Приведите ответ в свободной форме.


Прежде всего, определяем, какая работа будет доминировать:

Аналитическая нагрузка (чтение, агрегации, отчёты, Data Mining)?

Транзакционная нагрузка (частые обновления, критичность к целостности)?


Если аналитика и Big Data — приоритет:
Тогда выбор должен падать на колоночные и распределённые СУБД, потому что они:
Эффективны в агрегациях и сканировании больших массивов.
Масштабируются горизонтально.

ClickHouse — супербыстрая аналитика, подходит для realtime отчетов, масштабируется на кластеры.

Apache Druid — мощная для OLAP, отлично справляется с временными рядами и интерактивной аналитикой.

Presto/Trino — SQL-движок для распределённых запросов по множеству источников (можно подключить HDFS, S3, Kafka, PostgreSQL и т.д.).

Google BigQuery / Amazon Redshift / Snowflake — облачные варианты (если доступен cloud).

Если нужно выполнять распределённые вычисления (ETL, ML, MapReduce)
Тогда нужен движок распределённых вычислений, отдельно от СУБД, чтобы работать с данными без загрузки всего в RAM:

Лучшая модель — Apache Spark:

Поддерживает in-memory вычисления, которые в разы быстрее MapReduce.

Интегрируется с большинством СУБД и форматов (Parquet, Avro, ORC).

Умеет SQL, ML, графовую обработку и стриминг.

Можно разворачивать на 1000+ узлов с кластерными менеджерами (YARN, Kubernetes, Mesos).

Альтернатива:

Apache Flink — особенно хорош для обработки потоков данных в real-time.

Hadoop MapReduce — надёжный, но медленный по сравнению со Spark.

Резюме:
Тип СУБД	Распределённая аналитическая СУБД (ClickHouse, Druid)
Хранилище	HDFS / S3 / Ceph / локальные кластеры
Вычислительный движок	Apache Spark 
Управление кластером	YARN / Kubernetes / Spark Standalone
Язык обработки	SQL / PySpark / Scala

Почему Spark справится лучше всего:

Использует in-memory обработку — это критично при больших объёмах и необходимости быстрого ответа.

Распределяет вычисления по всему кластеру (1000 машин) и легко масштабируется.

Умеет обрабатывать данные из разных источников одновременно (базы, файлы, потоки).

Богатая экосистема: Spark MLlib, GraphX, Spark SQL, Spark Streaming.
